# Logstash configuration for Keycloak Kafka Event Listener
input {
  # Kafka input for user events
  kafka {
    bootstrap_servers => "kafka:29092"
    topics => ["keycloak.user.events"]
    group_id => "logstash-user-events"
    codec => "json"
    consumer_threads => 3
    auto_offset_reset => "latest"
    tags => ["keycloak", "user-events"]
  }

  # Kafka input for admin events
  kafka {
    bootstrap_servers => "kafka:29092"
    topics => ["keycloak.admin.events"]
    group_id => "logstash-admin-events"
    codec => "json"
    consumer_threads => 3
    auto_offset_reset => "latest"
    tags => ["keycloak", "admin-events"]
  }

  # Keycloak log files (if mounted)
  file {
    path => "/var/log/keycloak/*.log"
    start_position => "beginning"
    tags => ["keycloak", "application-logs"]
    codec => multiline {
      pattern => "^\d{4}-\d{2}-\d{2}"
      negate => true
      what => "previous"
    }
  }
}

filter {
  # Process user events
  if "user-events" in [tags] {
    # Parse timestamp
    date {
      match => ["time", "UNIX_MS"]
      target => "@timestamp"
    }

    # Add event classification
    mutate {
      add_field => { "event_category" => "user_activity" }
      add_field => { "event_subcategory" => "%{type}" }
      add_field => { "source_system" => "keycloak" }
    }

    # Enrich with geolocation if IP address is available
    if [ipAddress] {
      geoip {
        source => "ipAddress"
        target => "geoip"
      }
    }

    # Extract user agent details if available
    if [details][user_agent] {
      useragent {
        source => "[details][user_agent]"
        target => "user_agent"
      }
    }

    # Security event detection
    if [type] in ["LOGIN_ERROR", "INVALID_USER_CREDENTIALS", "USER_DISABLED"] {
      mutate {
        add_field => { "security_event" => "true" }
        add_field => { "alert_level" => "medium" }
      }
    }

    if [type] in ["INTROSPECT_TOKEN_ERROR", "PERMISSION_TOKEN_ERROR"] {
      mutate {
        add_field => { "security_event" => "true" }
        add_field => { "alert_level" => "high" }
      }
    }
  }

  # Process admin events
  if "admin-events" in [tags] {
    # Parse timestamp
    date {
      match => ["time", "UNIX_MS"]
      target => "@timestamp"
    }

    # Add event classification
    mutate {
      add_field => { "event_category" => "admin_activity" }
      add_field => { "event_subcategory" => "%{operationType}" }
      add_field => { "source_system" => "keycloak" }
    }

    # Extract admin user details
    mutate {
      add_field => { "admin_user_id" => "%{[authDetails][userId]}" }
      add_field => { "admin_realm" => "%{[authDetails][realmId]}" }
      add_field => { "admin_client" => "%{[authDetails][clientId]}" }
      add_field => { "admin_ip" => "%{[authDetails][ipAddress]}" }
    }

    # Critical admin operations
    if [operationType] in ["DELETE", "ACTION"] {
      mutate {
        add_field => { "critical_operation" => "true" }
        add_field => { "alert_level" => "high" }
      }
    }

    # Sensitive resource paths
    if [resourcePath] =~ /user/ {
      mutate {
        add_field => { "resource_type" => "user" }
      }
    } else if [resourcePath] =~ /realm/ {
      mutate {
        add_field => { "resource_type" => "realm" }
      }
    } else if [resourcePath] =~ /client/ {
      mutate {
        add_field => { "resource_type" => "client" }
      }
    }
  }

  # Process application logs
  if "application-logs" in [tags] {
    # Parse Keycloak log format
    grok {
      match => { 
        "message" => "%{TIMESTAMP_ISO8601:timestamp}\s+%{LOGLEVEL:level}\s+\[%{DATA:thread}\]\s+%{DATA:logger}\s+%{GREEDYDATA:log_message}" 
      }
    }

    # Convert log level to numeric for easier filtering
    if [level] == "ERROR" {
      mutate { add_field => { "level_numeric" => 4 } }
    } else if [level] == "WARN" {
      mutate { add_field => { "level_numeric" => 3 } }
    } else if [level] == "INFO" {
      mutate { add_field => { "level_numeric" => 2 } }
    } else if [level] == "DEBUG" {
      mutate { add_field => { "level_numeric" => 1 } }
    }

    # Extract Kafka-related errors
    if [log_message] =~ /kafka/i {
      mutate {
        add_field => { "component" => "kafka-event-listener" }
      }

      if [log_message] =~ /connection/i {
        mutate {
          add_field => { "error_type" => "connection" }
          add_field => { "alert_level" => "high" }
        }
      }

      if [log_message] =~ /timeout/i {
        mutate {
          add_field => { "error_type" => "timeout" }
          add_field => { "alert_level" => "medium" }
        }
      }
    }
  }

  # Common enrichment for all events
  mutate {
    add_field => { "indexed_at" => "%{@timestamp}" }
    add_field => { "environment" => "${ENVIRONMENT:development}" }
    add_field => { "version" => "0.0.2-SNAPSHOT" }
  }

  # Remove unnecessary fields
  mutate {
    remove_field => ["host", "path", "@version"]
  }
}

output {
  # Send to Elasticsearch
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "keycloak-events-%{+YYYY.MM.dd}"
    template_name => "keycloak-events"
    template => {
      "index_patterns" => ["keycloak-events-*"]
      "settings" => {
        "number_of_shards" => 1
        "number_of_replicas" => 0
        "index.refresh_interval" => "5s"
      }
      "mappings" => {
        "properties" => {
          "@timestamp" => { "type" => "date" }
          "event_category" => { "type" => "keyword" }
          "event_subcategory" => { "type" => "keyword" }
          "source_system" => { "type" => "keyword" }
          "realmId" => { "type" => "keyword" }
          "userId" => { "type" => "keyword" }
          "clientId" => { "type" => "keyword" }
          "sessionId" => { "type" => "keyword" }
          "ipAddress" => { "type" => "ip" }
          "type" => { "type" => "keyword" }
          "operationType" => { "type" => "keyword" }
          "resourcePath" => { "type" => "text" }
          "security_event" => { "type" => "boolean" }
          "critical_operation" => { "type" => "boolean" }
          "alert_level" => { "type" => "keyword" }
          "geoip" => {
            "properties" => {
              "location" => { "type" => "geo_point" }
              "country_name" => { "type" => "keyword" }
              "city_name" => { "type" => "keyword" }
            }
          }
        }
      }
    }
  }

  # Debug output (remove in production)
  if [environment] == "development" {
    stdout {
      codec => rubydebug {
        metadata => true
      }
    }
  }

  # Send high priority alerts to a separate index
  if [alert_level] in ["high", "critical"] {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "keycloak-alerts-%{+YYYY.MM.dd}"
    }
  }

  # Send metrics to Kafka for further processing
  kafka {
    bootstrap_servers => "kafka:29092"
    topic_id => "keycloak.metrics"
    codec => json
  }
}