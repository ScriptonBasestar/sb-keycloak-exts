// Integration Test Configuration
sourceSets {
    integrationTest {
        kotlin {
            srcDir 'src/integrationTest/kotlin'
        }
        resources {
            srcDir 'src/integrationTest/resources'
        }
        compileClasspath += main.output + test.output
        runtimeClasspath += main.output + test.output
    }
}

configurations {
    integrationTestImplementation.extendsFrom testImplementation
    integrationTestRuntimeOnly.extendsFrom testRuntimeOnly
}

// Duplicate handling strategy for processing resources
tasks.withType(ProcessResources) {
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}

dependencies {
    // Common Event Listener Module
    implementation project(':events:event-listener-common')

    // Redis Dependencies (Lettuce)
    implementation libs.lettuce.core

    // JSON Processing
    implementation libs.bundles.jackson
    implementation libs.bundles.logging

    // Test Dependencies
    testImplementation libs.bundles.testing
    testImplementation libs.testcontainers.junit
    testImplementation project(':events:event-listener-common')  // Common test utilities

    // Integration Test Dependencies
    testImplementation 'com.redis.testcontainers:testcontainers-redis:1.6.4'
    integrationTestImplementation libs.bundles.testcontainers
    integrationTestImplementation libs.keycloak.admin.client
}

// Integration Test Task
task integrationTest(type: Test) {
    description = 'Runs integration tests with TestContainers'
    group = 'verification'

    testClassesDirs = sourceSets.integrationTest.output.classesDirs
    classpath = sourceSets.integrationTest.runtimeClasspath

    shouldRunAfter test

    useJUnitPlatform()

    systemProperty 'junit.jupiter.execution.parallel.enabled', 'false'
    systemProperty 'testcontainers.reuse.enable', 'true'

    testLogging {
        events "passed", "skipped", "failed"
        exceptionFormat "full"
    }
}

check.dependsOn integrationTest

// Production Build Configuration
apply plugin: 'com.github.johnrengelman.shadow'

shadowJar {
    archiveClassifier.set('')
    archiveBaseName.set('keycloak-redis-event-listener')

    // Keycloak 플러그인 규칙에 따른 JAR 구성
    exclude 'META-INF/*.SF'
    exclude 'META-INF/*.DSA'
    exclude 'META-INF/*.RSA'
    exclude 'META-INF/MANIFEST.MF'

    // Lettuce 클라이언트와 Jackson 라이브러리 포함
    dependencies {
        include(dependency('io.lettuce:lettuce-core'))
        include(dependency('com.fasterxml.jackson.core:jackson-core'))
        include(dependency('com.fasterxml.jackson.core:jackson-databind'))
        include(dependency('com.fasterxml.jackson.module:jackson-module-kotlin'))
    }

    // Manifest 설정
    manifest {
        attributes(
            'Implementation-Title': 'Keycloak Redis Event Listener',
            'Implementation-Version': project.version,
            'Implementation-Vendor': 'ScriptonBaseStar',
            'Built-By': System.getProperty('user.name'),
            'Build-Date': new Date().format('yyyy-MM-dd HH:mm:ss'),
            'Keycloak-Version': libs.versions.keycloak.get()
        )
    }
}

// Production Build Task
task productionBuild {
    group = 'build'
    description = 'Builds production-ready JAR for Keycloak deployment'

    dependsOn clean, test, integrationTest, shadowJar

    doLast {
        def jarFile = shadowJar.archiveFile.get().asFile
        def checksumFile = new File(jarFile.parent, "${jarFile.name}.sha256")

        // SHA256 체크섬 생성
        def checksum = java.security.MessageDigest.getInstance("SHA-256")
            .digest(jarFile.bytes)
            .encodeHex()
            .toString()

        checksumFile.text = "${checksum}  ${jarFile.name}\n"

        println "Production JAR built: ${jarFile.absolutePath}"
        println "Checksum: ${checksum}"
        println "Size: ${jarFile.length()} bytes"
    }
}

// JAR 서명을 위한 태스크 (선택사항)
task signJar(type: Sign) {
    group = 'build'
    description = 'Signs the production JAR'

    sign shadowJar
}

// 배포를 위한 아티팩트 준비
task prepareDistribution(type: Copy) {
    group = 'distribution'
    description = 'Prepares distribution artifacts'

    dependsOn productionBuild

    from shadowJar.archiveFile
    from "${shadowJar.archiveFile.get().asFile.parent}/${shadowJar.archiveFile.get().asFile.name}.sha256"
    from file('README.md')
    from file('LICENSE')

    into "${buildDir}/distribution"
}
